import Joi from 'joi'
import { ObjectId } from 'mongodb'
import { getDB } from 'config/mongodb'
import {
  PlaceFindStageByQuality,
  PlaceFilterKeywords,
  QueryValueSeperator
} from 'utilities/constants'
import {
  createLookupStage,
  createObjectIDByString,
  createProjectionStage,
  getExpectedFieldsProjection,
  PlaceFindStages,
  SpecialtyPlaceFields,
  SpecialtyPlaceFieldStageNames
} from 'utilities/mongo'

import { mapCollectionSchema } from 'schemas/place.schema'

// Define Map collection
const mapCollectionName = 'maps'


// Phuong: ƒê√¢y l√† nh·ªØng tr∆∞·ªùng kh√¥ng ƒë∆∞·ª£c update (gi√° tr·ªã c·ªë ƒë·ªãnh kh√¥ng ƒë·ªïi)
const INVALID_UPDATE_FILEDS = ['_id', 'place_id', 'createdAt']

// Phuong: T·∫°o Schema ƒë·ªÉ mongodb bi·∫øt t·∫°o b·∫£ng ntn
const validateSchema = async (data) => {
  return await mapCollectionSchema.validateAsync(data, { abortEarly: false })
}

// Phuong: T√¨m d·ª±a tr√™n id c·ªßa map.
const findOneById = async (id) => {
  try {
    const result = await getDB().collection(mapCollectionName)
    // Phuong: B·ªüi v√¨ key _id trong mongodb ƒëuc·ª£ luu ·ªü d·∫°ng ObjectId n√™n ph·∫£i
    // Phuong: chuy·ªÉn qua ObjectId t·ª´ ph√≠a client ƒë·∫©y l√™n m·ªõi t√¨m ƒë∆∞·ª£c
      .findOne({ _id: new ObjectId(id) })
    return result
  } catch (error) {
    throw new Error(error)
  }
}

// Phuong: T√¨m d·ª±a tr√™n place_id
const findOneByPlaceId = async (place_id) => {
  try {
    const result = await getDB().collection(mapCollectionName).findOne({ place_id: place_id })
    return result
  } catch (error) {
    throw new Error(error)
  }
}

// Phuong: T√¨m d·ª±a tr√™n place_id nh∆∞ng b·∫Øt ƒë·∫ßu b·∫±ng k√≠ t·ª± 1 v√† k·∫øt th√∫c b·∫±ng k√≠ t·ª± 2
const findOneByPlaceIdStartEnd = async (firstString, lastString) => {
  try {
    const regexPattern = new RegExp(`^${firstString}.*${lastString}$`)
    const result = await getDB().collection(mapCollectionName).find({ place_id: { $regex: regexPattern } }).toArray()
    console.log('üöÄ ~ file: map.model.js:118 ~ findOneByPlaceIdStartEnd ~ result:', result)
    return result
  } catch (error) {
    throw new Error(error)
  }
}

// Tuan: L·∫•y t·∫•t c·∫£ c√°c d·ªØ li·ªáu c·ªßa places, c√≥ gi·ªõi h·∫°n.
/**
 * Method n√†y d√πng ƒë·ªÉ tr·∫£ v·ªÅ m·ªôt m·∫£ng d·ªØ li·ªáu c·ªßa places. C√≥ filter, limit v√† skip. Ngo√†i ra
 * th√¨ c√≥ th·ªÉ y√™u c·∫ßu c√°c tr∆∞·ªùng d·ªØ li·ªáu c·∫ßn tr·∫£ v·ªÅ.
 * @param {{[key: string]: string}} filter Object ch·ª©a c√°c filter theo ti√™u chu·∫©n c·ªßa mongo, nh∆∞ng ƒë·ªìng th·ªùi c≈©ng ph·∫£i th·ªèa scheme c·ªßa Place.
 * @param {{[key: string]: string}} fields Object ch·ª©a c√°c field-true ƒë·ªÉ l·∫•y c√°c tr∆∞·ªùng d·ªØ li·ªáu mong mu·ªën.
 * @param {number} limit S·ªë records gi·ªõi h·∫°n ƒë∆∞·ª£c tr·∫£ v·ªÅ.
 * @param {number} skip S·ªë records mu·ªën mongo b·ªè qua.
 * @returns
 */
const findManyInLimit = async (filter, fields, limit = 10, skip = 0) => {
  try {
    console.log(fields)
    const cursor = getDB().collection(mapCollectionName).find(filter, { projection: fields }).limit(limit).skip(skip)
    const result = await cursor.toArray()
    return result
  } catch (error) {
    throw new Error(error)
  }
}

// Tuan: L·∫•y t·∫•t c·∫£ c√°c d·ªØ li·ªáu c·ªßa places, c√≥ gi·ªõi h·∫°n.
/**
 * Method n√†y d√πng ƒë·ªÉ tr·∫£ v·ªÅ m·ªôt m·∫£ng d·ªØ li·ªáu c·ªßa places. C√≥ filter, limit v√† skip. Ngo√†i ra
 * th√¨ c√≥ th·ªÉ y√™u c·∫ßu c√°c tr∆∞·ªùng d·ªØ li·ªáu c·∫ßn tr·∫£ v·ªÅ.
 * @param {string} filter Object ch·ª©a c√°c filter theo ti√™u chu·∫©n c·ªßa mongo, nh∆∞ng ƒë·ªìng th·ªùi c≈©ng ph·∫£i th·ªèa scheme c·ªßa Place.
 * @param {string} fields Object ch·ª©a c√°c field-true ƒë·ªÉ l·∫•y c√°c tr∆∞·ªùng d·ªØ li·ªáu mong mu·ªën.
 * @param {number} limit S·ªë records gi·ªõi h·∫°n ƒë∆∞·ª£c tr·∫£ v·ªÅ.
 * @param {number} skip S·ªë records mu·ªën mongo b·ªè qua.
 * @returns
 */
const findManyInLimitWithPipeline = (function() {
  return async (data) => {
    let { filter, fields, limit = 10, skip = 0, user } = data
    try {
      // ƒê·∫ßu ti√™n th√¨ split c√°i filter ra b·∫±ng kho·∫£ng tr·∫Øng;
      let filters = filter.split(' ')
      let addFieldsStage = { $addFields: {} }
      let projectStage = {
        '$project': {}
      }
      // T g·ªçi c√°i n√†y l√† find stage l√† b·ªùi v√¨ n√≥ s·∫Ω t√¨m record theo $match
      let findStage = {
        match: {
          $match: {}
        },
        others: []
      }

      for (let filter of filters) {
        let [key, value] = filter.split(':')
        let hasQuality = key.includes('quality')
        let expression = PlaceFindStages.quality.expressions[value] || PlaceFindStages[key].expressions[key]
        if (!expression()['$match']) findStage.others.push(expression())
        if (hasQuality) {
          findStage.match['$match'] = { ...findStage.match['$match'], ...expression()['$match'] }
          continue
        }
        if (!hasQuality) {
          findStage.match['$match'] = { ...findStage.match['$match'], ...expression(value)['$match'] }
          continue
        }
      }

      // console.log('FIND STAGE: ', findStage)

      addFieldsStage.$addFields = {
        place_photos: { '$arrayElemAt': ['$place_photos.photos', 0] }
      }
      if (user) {
        addFieldsStage.$addFields[SpecialtyPlaceFields.isLiked.field] = {
          $in: ['$place_id', user.savedPlaces]
        }
        addFieldsStage.$addFields[SpecialtyPlaceFields.isVisited.field] = {
          $in: ['$place_id', user.visitedPlaces]
        }
      }

      if (fields) fields += `;place_photos;${SpecialtyPlaceFields.isLiked.field};${SpecialtyPlaceFields.isVisited.field}`
      projectStage.$project = { ...getExpectedFieldsProjection(fields) }

      const pipeline = [
        findStage.match,
        ...findStage.others,
        {
          '$lookup': {
            'from': 'photos',
            'localField': 'place_id',
            'foreignField': 'place_photos_id',
            'as': 'place_photos'
          }
        }
      ]

      if (Object.keys(projectStage.$project).length >= 1) pipeline.push(projectStage)

      pipeline.push(addFieldsStage, { '$skip': skip }, { '$limit': limit })
      console.log('Pipeline: ', pipeline)
      const cursor = getDB().collection(mapCollectionName).aggregate(pipeline)
      const result = await cursor.toArray()
      return result
    } catch (error) {
      console.error(error.message)
      return undefined
    }
  }})()

/**
 * H√†m n√†y d√πng ƒë·ªÉ t√¨m th√¥ng tin chi ti·∫øt c·ªßa m·ªôt ƒë·ªãa ƒëi·ªÉm n√†o ƒë√≥.
 * @param {*} data
 * @returns
 */
const findOneWithPipeline = (function() {
  /*
    Khai b·∫£o c√°c fields ƒë·∫∑c bi·ªát (Ch√≠nh l√† c√°c fields ƒë∆∞·ª£c lookup)
    L·∫•y d·ªØ li·ªáu n√†y ho·∫°t ƒë·ªông theo ki·ªÉu:
    - N·∫øu nh∆∞ fields l√† r·ªóng, th√¨ n√≥ s·∫Ω l·∫•y t·∫•t c·∫£ fields trong place.
    - N·∫øu nh∆∞ fields ch·ª©a m·ªôt hay nhi·ªÅu fields ƒë·∫∑c bi·ªát fn n√†y s·∫Ω l·∫•y d·ªØ li·ªáu t·∫•t c·∫£ c√°c fields trong
    place c√πng v·ªõi m·ªôt hay nhi·ªÅu fields ƒë·∫∑c bi·ªát.
    - N·∫øu nh∆∞ fields ch·ª©a m·ªôt hay nhi·ªÅu fields ƒë·∫∑c v√† c√≥ m·ªôt hay nhi·ªÅu fields trong place, th√¨
    fn n√†y s·∫Ω l·∫•y d·ªØ li·ªáu c·ªßa m·ªôt hay nhi·ªÅu fields ƒë·∫∑c bi·ªát c√πng v·ªõi m·ªôt hay nhi·ªÅu fields trong place.
    V√† nh∆∞ ƒë√£ n√≥i th√¨ khi lookup c√°c fields ƒë·∫∑c bi·ªát, m√¨nh ph·∫£i th√™m c√°c stage kh√°c h·ªó tr·ª£. Cho n√™n trong
    bi·∫øn n√†y m√¨nh s·∫Ω khai b√°o th√™m c√°c data cho c√°c stage ƒë√≥.
  */
  // let specialtyFields = {
  //   reviews: {
  //     field: 'reviews',
  //     addFieldsStage:  { '$arrayElemAt': ['$reviews.reviews', 0] },
  //     lookupStage: {
  //       from: 'reviews',
  //       localField: 'place_id',
  //       foreignField: 'place_reviews_id',
  //       as: 'reviews'
  //     }
  //   },
  //   content: {
  //     field: 'content',
  //     addFieldsStage:  { '$arrayElemAt': ['$content', 0] },
  //     lookupStage: {
  //       from: 'content',
  //       localField: undefined,
  //       foreignField: undefined,
  //       as: 'content',
  //       options: {
  //         extras: {
  //           let: { pid: '$content_id' }
  //         },
  //         pipeline: [
  //           {
  //             $match: {
  //               $expr: {
  //                 $eq: ['$_id', { $toObjectId: '$$pid' }]
  //               }
  //             }
  //           },
  //           {
  //             $project: {
  //               plainTextMarkFormat: true,
  //               plainTextBase64: true,
  //               speech: true
  //             }
  //           }
  //         ]
  //       }
  //     }
  //   },
  //   isLiked: {
  //     field: 'isLiked'
  //   }
  // }

  return async (data, user) => {
    try {
      // url ch·ªâ nh·∫≠n 2 query l√† placeId v√† fields (c√≥ th·ªÉ update th√™m)
      // userId c√≥ th·ªÉ undefined b·ªüi v√¨ kh√¥ng ph·∫£i l√∫c n√†o c≈©ng c√≥ th·ªÉ
      let {
        placeId,
        fields,
        lang
      } = data
      console.log('REQUESTED FIELDS: ', fields)
      // Khai b√°o pipeline. Stage ƒë·∫ßu ti√™n l√† m√¨nh ki·∫øm ra c√°c document n√†y tr∆∞·ªõc.
      // N·∫øu nh∆∞ t√¨m ƒë∆∞·ª£c 1 document th√¨ n√≥ s·∫Ω ch·ªâ tr·∫£ v·ªÅ m·ªôt document trong m·ªôt m·∫£ng.
      // V√† v√¨ m·ªói place ch·ªâ c√≥ m·ªôt placeId cho n√™n l√† ch·ªâ lu√¥n t√¨m ƒë∆∞·ª£c m·ªôt id.
      let pipeline = [
        {
          '$match': { 'place_id': placeId }
        }
      ]
      // Stage n√†y d√πng ƒë·ªÉ ch·ªçn c√°c fields data mong mu·ªën trong `fields`.
      let placeDetailsProjectionStage
      // Stage n√†y h·ªó tr·ª£ cho stage ·ªü tr√™n, d√πng ƒë·ªÉ th√™m c√°c field b√™n ngo√†i trong qu√° tr√¨nh lookup
      // Trong ƒë√≥ c√≥ reviews v√† content.
      let addFieldsStage = []
      if (lang) {
        SpecialtyPlaceFields.content.stages['lookup']['$lookup'].pipeline[1].$project.speech = { [lang]: true }
        SpecialtyPlaceFields.content.stages['lookup']['$lookup'].pipeline[1].$project.plainTextBase64 = { [lang]: true }
        SpecialtyPlaceFields.content.stages['lookup']['$lookup'].pipeline[1].$project.plainTextMarkFormat = { [lang]: true }
      }

      for (let key in SpecialtyPlaceFields) {
        /*
          ·ªû ƒë√¢y m√¨nh check th√™m vi·ªác l√† c√≥ ph·∫£i m·ªôt ng∆∞·ªùi d√πng trong app y√™u c·∫ßu hay kh√¥ng?
          N·∫øu c√≥ th√¨ m√¨nh check lu√¥n l√† place n√†y c√≥ ƒë∆∞·ª£c ng∆∞·ªùi d√πng y√™u th√≠ch hay kh√¥ng?
          Hay l√† ƒë√£ ƒë∆∞·ª£c ng∆∞·ªùi d√πng n√†y gh√© thƒÉm hay ch∆∞a? isLiked v√† isVisited c≈©ng l√† 2
          fields ƒë·∫∑c bi·ªát, nh∆∞ng kh√°c v·ªõi 2 field kia l√† 2 fields n√†y kh√¥ng d√πng $lookup.
        */
        if (key === SpecialtyPlaceFields.isLiked.field || key === SpecialtyPlaceFields.isVisited.field) {
          if (Boolean(fields) && !fields.includes(key)) fields += `;${key}`
          if (user) {
            let arrVal = key === SpecialtyPlaceFields.isLiked.field ? user.savedPlaces : user.visitedPlaces
            if (!addFieldsStage[0]) addFieldsStage[0] = { '$addFields': {} }
            addFieldsStage[0]['$addFields'][key] = {
              $in: ['$place_id', arrVal]
            }
          }
          continue
        }

        for (let stageKey in SpecialtyPlaceFieldStageNames) {
          if (fields && !fields.includes(key)) continue
          let stage = SpecialtyPlaceFields[key].stages[stageKey]

          if (!addFieldsStage[0]) addFieldsStage[0] = { '$addFields': {} }
          if (stageKey === SpecialtyPlaceFieldStageNames.addFields) {
            addFieldsStage[0]['$addFields'][key] = stage['$addFields']
          }

          if (stageKey === SpecialtyPlaceFieldStageNames.lookup) {
            pipeline.push(stage)
          }

        }
      }
      // T·∫°o project stage cho c√°c fields c·ªßa place. N·∫øu nh∆∞ fields ch·ªâ ch·ª©a c√°c fields ƒë·∫∑c bi·ªát ho·∫∑c
      // l√† kh√¥ng c√≥ fields n√†o th√¨ n√≥ s·∫Ω tr·∫£ v·ªÅ r·ªóng.
      placeDetailsProjectionStage = createProjectionStage(getExpectedFieldsProjection(fields))
      pipeline.push(...addFieldsStage, ...placeDetailsProjectionStage)
      // console.log('MAP MODEL findOneWithPipeline (addFieldsStage): ', addFieldsStage[0]['$addFields']['content'])
      // console.log('MAP MODEL findOneWithPipeline (addFieldsStage): ', addFieldsStage[0]['$addFields']['reviews'])
      console.log('MAP MODEL findOneWithPipeline (pipeline): ', pipeline)
      const cursor = getDB().collection(mapCollectionName).aggregate(pipeline)
      const result = await cursor.toArray()
      return result[0]
    } catch (error) {
      console.error(error.message)
      return undefined
    }
  }
})()

// Ph∆∞∆°ng: t·∫°o m·ªõi map
const createNew = async (data) => {
  try {
    const validatedValue = await validateSchema(data)

    const result = await getDB().collection(mapCollectionName).insertOne(validatedValue)
    return result
  } catch (error) {
    throw new Error(error)
  }
}

// Phuong: C·∫≠p nh·∫≠t map th√¥ng qua place_id
const updateByPlaceId = async (place_id, data) => {
  try {
    const updateData = { ...data }

    // Phuong: CH·ªó n√†y l√† x√≥a nh·ªØng tr∆∞·ªùng m√† m√¨nh kh√¥ng cho ph√©p update
    Object.keys(updateData).forEach(fieldName => {
      if (INVALID_UPDATE_FILEDS.includes(fieldName)) {
        delete updateData[fieldName]
      }
    })

    const result = await getDB().collection(mapCollectionName).findOneAndUpdate(
      { place_id: place_id },
      { $set: updateData },
      { returnDocument: 'after' }
    )

    return result.value
  } catch (error) {
    throw new Error(error)
  }
}

const createManyPlaces = async (places) => {
  // console.log('üöÄ ~ file: map.model.js:141 ~ createManyPlaces ~ places', places)
  try {
    // Phuong: https://www.mongodb.com/docs/v6.0/reference/method/db.collection.insertMany/#mongodb-method-db.collection.insertMany
    const result = await getDB().collection(mapCollectionName).insertMany(places)
    console.log('üöÄ ~ Successfully ~ createManyPlaces ~ places')

    return result
  } catch (error) {
    throw new Error(error)
  }
}

export const MapModel = {
  mapCollectionName,
  createNew,
  updateByPlaceId,
  findOneById,
  findOneWithPipeline,
  findOneByPlaceId,
  findManyInLimit,
  findManyInLimitWithPipeline,
  createManyPlaces
}

