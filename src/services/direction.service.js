import { DirectionModel } from 'models/direction.model'

import { PlacesSearchProvider } from 'providers/PlacesSearchProvider'
import { SendMessageToSlack } from 'providers/SendMessageToSlack'
import { RedisQueueProvider } from 'providers/RedisQueueProvider'

import { FilterConstants, MapApiStatus } from 'utilities/constants'
import axios from 'axios'
import { env } from 'config/environtment'
import { Buffer } from 'buffer'
import { cloneDeep, result, sortBy } from 'lodash'
import { filterRadiusProminenceOrNearBy, sortByRatingHighToLow, sortByRatingLowToHigh, sortByStarHighToLow, sortByStarLowToHigh } from 'utilities/function'
import { OpenRouteServiceProvider } from 'providers/OpenRouteServiceProvider'
import polyline from '@mapbox/polyline'
import { GeocodingGoogleMapProvider } from 'providers/GeocodingGoogleMapProvider'
import { DirectionGoogleMapProvider } from 'providers/DirectionGoogleMapProvider'
import { ChatGptProvider } from 'providers/ChatGptProvider'
import { RoutesGoogleMapProvider } from 'providers/RoutesGoogleMapProvider'
import { LangChainProvider } from 'providers/LangChainProvider'

const getRouteDirection = async (data) => {
  // data c√≥ d·∫°ng:
  // data = {
  //   oriAddress: 'abc' || null,
  //   desAddress: 'abc' || null,
  //   oriPlaceId: sdgkl_27e921 || null,
  //   desPlaceId: sdgkl_27e921 || null,
  //   oriCoor: {
  //      longitude: 10.214290,
  //      latitude: 100.1283824
  // } || null,
  //   desCoor: {
  //      longitude: 10.214290,
  //      latitude: 100.1283824
  // } || null,
  //   modeORS: 'driving-car',
  //   modeGCP: 'driving',
  //   typeOri: 'place_id' || 'address' || 'coordinate',
  //   typeDes: 'place_id' || 'address' || 'coordinate',
  //   routeModifiers: {
  //   avoidTolls: false,
  //   avoidHighways: false,
  //   avoidFerries: false,
  //   avoidIndoor: false
  //   },
  //   languageCode: 'vi'
  // }
  console.log('üöÄ ~ file: direction.service.js:256 ~ getPlaceDetails ~ data:', data)
  try {
    let oriToCheck
    let desToCheck

    let result

    if (data.typeOri === 'place_id') {
      oriToCheck = data.oriPlaceId
    } else if (data.typeOri === 'address') {
      // geocoding 2 th·∫±ng origin v√† destination ƒë·ªÉ l·∫•y ch√≠nh x√°c place_id ƒë·ªÉ ƒëi ki·ªÉm tra trong db
      const geocodingOri = GeocodingGoogleMapProvider.getPlaceIdFromAddress(data.oriAddress)
      oriToCheck = geocodingOri.place_id
    } else if (data.typeOri === 'coordinate') {
      // geocoding 2 th·∫±ng origin v√† destination ƒë·ªÉ l·∫•y ch√≠nh x√°c place_id ƒë·ªÉ ƒëi ki·ªÉm tra trong db
      oriToCheck = await GeocodingGoogleMapProvider.getPlaceIdFromCoords(data.oriCoor.latitude, data.oriCoor.longitude)
    }

    if (data.typeDes === 'place_id') {
      desToCheck = data.desPlaceId
    } else if (data.typeDes === 'address') {
      // geocoding 2 th·∫±ng origin v√† destination ƒë·ªÉ l·∫•y ch√≠nh x√°c place_id ƒë·ªÉ ƒëi ki·ªÉm tra trong db
      const geocodingDes = GeocodingGoogleMapProvider.getPlaceIdFromAddress(data.oriAddress)
      desToCheck = geocodingDes.place_id
    } else if (data.typeDes === 'coordinate') {
      // geocoding 2 th·∫±ng origin v√† destination ƒë·ªÉ l·∫•y ch√≠nh x√°c place_id ƒë·ªÉ ƒëi ki·ªÉm tra trong db
      desToCheck = await GeocodingGoogleMapProvider.getPlaceIdFromCoords(data.desCoor.latitude, data.desCoor.longitude)
    }

    console.log('oriToCheck', oriToCheck)
    console.log('desToCheck', desToCheck)
    // Ki·ªÉm tra trong database xem c√≥ geocoded_waypoints c√≥ hai ƒë·ª©a n√†y kh√¥ng
    let checkWaypointsDb = await DirectionModel.findOriDesPlaceId(oriToCheck, desToCheck)
    console.log('üöÄ ~ file: direction.service.js:72 ~ getRouteDirection ~ checkWaypointsDb:', checkWaypointsDb)

    const indexOfWay = checkWaypointsDb.findIndex(way => way.transport === data.modeGCP)
    // n·∫øu indexOfWay = -1 l√† t√¨m kh√¥ng th·∫•y
    if (checkWaypointsDb.length !== 0 && indexOfWay !== -1) {
      console.log('L·∫•y trong DB')
      console.log('üöÄ ~ file: direction.service.js:83 ~ getRouteDirection ~ indexOfWay:', indexOfWay)

      console.log('üöÄ vaof ~ indexOfWay:')

      // N·∫øu c√≥ th√¨ l·∫•y v·ªÅ lu√¥n. √Ä qu√™n ƒë·ªëi v·ªõi GCP c√≤n ph·∫£i encode points
      // Mu·ªën decode th√¨ s·∫Ω ti·∫øp c·∫≠n t·ª´ routes(l√† m·∫£ng -> s·ªë ƒë∆∞·ªùng ƒëi t·ª´ A -> B)
      if (checkWaypointsDb[indexOfWay].callFrom === 'GCP') {
        checkWaypointsDb[indexOfWay].data.routes.map(route => {
          const legs = route.legs
          if (legs) {
            legs.map(leg => {
              // x·ª≠ l√Ω th·∫±ng duration v√† staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
              leg.duration = Number(leg.duration.split('s')[0])
              leg.staticDuration = Number(leg.staticDuration.split('s')[0])

              const steps = leg.steps
              if (steps) {
                steps.map(step => {
                  // x·ª≠ l√Ω th·∫±ng staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
                  step.staticDuration = Number(step.staticDuration.split('s')[0])

                  const points = polyline.decode(step.polyline.encodedPolyline)
                  const pointsToUpdate = []
                  points.map(point => pointsToUpdate.push({ latitude: point[0], longitude: point[1] }))
                  step.polyline = pointsToUpdate
                })
              }
            })
          }
          // X·ª≠ l√Ω decode polyline
          const points = polyline.decode(route.polyline.encodedPolyline)
          const pointsToUpdate = []
          points.map(point => pointsToUpdate.push({ latitude: point[0], longitude: point[1] }))
          route.polyline = pointsToUpdate
          // x·ª≠ l√Ω th·∫±ng duration v√† staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
          route.duration = Number(route.duration.split('s')[0])
          route.staticDuration = Number(route.staticDuration.split('s')[0])
        })
      }

      result = {
        data: checkWaypointsDb[indexOfWay].data,
        callFrom: checkWaypointsDb[indexOfWay].callFrom,
        oriPlaceId: oriToCheck ? oriToCheck : null,
        desPlaceId: desToCheck ? desToCheck : null
      }
      console.log('üöÄ ~ file: direction.service.js:125 ~ getRouteDirection ~ result:', result)

    } else {
    // N·∫øu kh√¥ng c√≥ th√¨ ph·∫£i g·ªçi th·∫±ng GCP direction
      console.log('Call API')

      let drirection
      let body = {
        origin: oriToCheck ? { placeId: oriToCheck } : { latitude: data.oriCoor.latitude, longitude: data.oriCoor.longitude },
        destination: desToCheck ? { placeId: desToCheck } : { latitude: data.desCoor.latitude, longitude: data.desCoor.longitude },
        mode: data.modeGCP,
        routeModifiers: data.routeModifiers,
        languageCode: data.languageCode
      }

      if (!body.routeModifiers) {
        delete body.routeModifiers
      }

      let directionTranformYet
      drirection = await RoutesGoogleMapProvider.getComputeRoutesGCP(body)


      if (!drirection.error) {
        // N·∫øu th·∫±ng drirection tr·∫£ v·ªÅ kh√¥ng c√≥ routes nghƒ©a l√† kh√¥ng t√¨m th·∫•y
        if (!drirection.routes || drirection.routes.length === 0) {
          return {
            error: 'This route is not supported or not found!'
          }
        }
        // Bi·∫øn ƒë·ªïi d·ªØ li·ªáu tr·∫£ v·ªÅ
        directionTranformYet = cloneDeep(drirection)
        drirection.routes.map(route => {
          const legs = route.legs
          if (legs) {
            legs.map(leg => {
              // x·ª≠ l√Ω th·∫±ng duration v√† staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
              leg.duration = Number(leg.duration.split('s')[0])
              leg.staticDuration = Number(leg.staticDuration.split('s')[0])

              const steps = leg.steps
              if (steps) {
                steps.map(step => {
                  // x·ª≠ l√Ω th·∫±ng staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
                  step.staticDuration = Number(step.staticDuration.split('s')[0])

                  const points = polyline.decode(step.polyline.encodedPolyline)
                  const pointsToUpdate = []
                  points.map(point => pointsToUpdate.push({ latitude: point[0], longitude: point[1] }))
                  step.polyline = pointsToUpdate
                })
              }
            })
          }
          // X·ª≠ l√Ω decode polyline
          const points = polyline.decode(route.polyline.encodedPolyline)
          const pointsToUpdate = []
          points.map(point => pointsToUpdate.push({ latitude: point[0], longitude: point[1] }))
          route.polyline = pointsToUpdate
          // x·ª≠ l√Ω th·∫±ng duration v√† staticDuration t√°ch s ra chuy·ªÉn v·ªÅ number
          route.duration = Number(route.duration.split('s')[0])
          route.staticDuration = Number(route.staticDuration.split('s')[0])
        })
        result = {
          data: drirection,
          callFrom: 'GCP',
          transport: data.modeGCP,
          oriPlaceId: oriToCheck ? oriToCheck : null,
          desPlaceId: desToCheck ? desToCheck : null
        }
      }
      // else {
      // // data c√≥ d·∫°ng:
      // // data = {
      // //   start: [18.21834812848, 67.2194214],
      // //   end: [19.21834812848, 68.2194214],
      // //   profile: 'driving-car'
      // // }
      //   const resultORS = await OpenRouteServiceProvider.getDirectionsORS({
      //     start: [data.oriCoor.longitude, data.oriCoor.latitude],
      //     end: [data.desCoor.longitude, data.desCoor.latitude],
      //     profile: data.modeORS,
      //     api_key: env.ORS_API_KEY1
      //   })

      //   directionTranformYet = cloneDeep(resultORS)
      //   result = {
      //     data: resultORS,
      //     callFrom: 'ORS',
      //     transport: data.modeORS
      //   }
      // }

      // // l∆∞u v√†o backgoundjob
      // // B∆∞·ªõc 1: Kh·ªüi t·∫°o m·ªôt h√†ng ƒë·ª£i ƒë·ªÉ c·∫≠p nh·∫≠t comment c·ªßa nhi·ªÅu card
      // const dataToSave = {
      //   callFrom: result.callFrom,
      //   transport: result.transport,
      //   data: directionTranformYet,
      //   geocoded_waypoints: [oriToCheck, desToCheck]
      // }

      // dataToSave
      // let updatedDirectionQueue = RedisQueueProvider.generateQueue('updatedDirectionQueue')
      // // B∆∞·ªõc 2: ƒê·ªãnh nghƒ©a ra nh·ªØng vi·ªác c·∫ßn l√†m trong ti·∫øn tr√¨nh h√†ng ƒë·ª£i
      // updatedDirectionQueue.process(async (job, done) => {
      //   try {
      //   // job.data ·ªü ƒë√¢y ch√≠nh l√† dataToSave ƒë∆∞·ª£c truy·ªÅn v√†o t·ª´ b∆∞·ªõc 4
      //     const directionUpdated = await DirectionModel.createNew(job.data)
      //     done(null, directionUpdated)
      //   } catch (error) {
      //     done(new Error('Error from updatedDirectionQueue.process'))
      //   }
      // })
      // // B3: Check completed ho·∫∑c failed, t√πy tr∆∞·ªùng h·ª£p y√™u c·∫ßu m√† c·∫ßn c√°i event n√†y, ƒë·ªÉ b·∫Øn th√¥ng b√°o khi job ch·∫°y xong ch·∫≥ng h·∫°n
      // // Nhi·ªÅu event kh√°c: https://github.com/OptimalBits/bull/blob/HEAD/REFERENCE.md#events
      // updatedDirectionQueue.on('completed', (job, result) => {
      // // B·∫Øn k·∫øt qu·∫£ v·ªÅ Slack
      //   SendMessageToSlack.sendToSlack(`Job v·ªõi id l√†: ${job.id} v√† t√™n job: *${job.queue.name}* ƒë√£ *xong* v√† k·∫øt qu·∫£ l√†: ${result}`)
      // })

      // updatedDirectionQueue.on('failed', (job, error) => {
      // // B·∫Øn l·ªói v·ªÅ Slack ho·∫∑c Telegram ...
      //   SendMessageToSlack.sendToSlack(`Notification: Job v·ªõi id l√† ${job.id} v√† t√™n job l√† *${job.queue.name}* ƒë√£ b·ªã *l·ªói* \n\n ${error}`)
      // })

      // // B∆∞·ªõc 4: b∆∞·ªõc quan tr·ªçng cu·ªëi c√πng: Th√™m v√†o v√†o ƒë·ª£i Redis ƒë·ªÉ x·ª≠ l√Ω
      // updatedDirectionQueue.add(dataToSave, {
      //   attempts: 2, // s·ªë l·∫ßn th·ª≠ l·∫°i n·∫øu l·ªói
      //   backoff: 5000 //kho·∫£ng th·ªùi gian delay gi·ªØa c√°c l·∫ßn th·ª≠ l·∫°i job
      // })
    }

    // d·ªØ li·∫πu tr·∫£ v·ªÅ theo d·∫°ng:
    // data: {
    //   data: k·∫øt qu·∫£ t∆∞∆°ng ·ª©ng
    //   callFrom: 'ORS' || 'GCP'
    // }

    console.log('üöÄ ~ file: direction.service.js:210 ~ getRouteDirection ~ result:', result)
    return result
  } catch (error) {
    // console.log(error)
    throw new Error(error)
  }
}

const getChatGptItinerary = async (data) => {
  console.log('üöÄ ~ file: direction.service.js:214 ~ getRouteDirection ~ data:', data)
  try {
    const result = await LangChainProvider.getMessage(data.textInput)
    return result
  } catch (error) {
    // console.log(error)
    throw new Error(error)
  }
}

export const DirectionService = {
  getRouteDirection,
  getChatGptItinerary
}
